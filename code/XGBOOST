import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import STL
from sklearn.metrics import mean_squared_error, mean_absolute_error
from sklearn.model_selection import RandomizedSearchCV, TimeSeriesSplit
import xgboost as xgb
import warnings

# Suppress warnings
warnings.filterwarnings('ignore')

def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / np.clip(y_true, 1e-8, None))) * 100

# Plotting Function for Consistent Style

def styled_plot(x, y_actual, y_pred=None, title="", xlabel="Date", ylabel="Solar Radiation", save_path=None):
    plt.figure(figsize=(14, 6), dpi=300)
    plt.plot(x, y_actual, label="Actual Radiation", color="green", linewidth=2, linestyle='--')
    if y_pred is not None:
        plt.plot(x, y_pred, label="Predicted Radiation", color="orange", linewidth=1.5, linestyle='-')

    plt.title(title, fontsize=18, fontweight='bold', fontname="Times New Roman")
    plt.xlabel(xlabel, fontsize=16, fontweight='bold', fontname="Times New Roman")
    plt.ylabel(ylabel, fontsize=16, fontweight='bold', fontname="Times New Roman")
    plt.xticks(fontsize=14, fontname="Times New Roman")
    plt.yticks(fontsize=14, fontname="Times New Roman")
    plt.legend(fontsize=14)
    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.show()
    plt.close()


# Load and preprocess data

df = pd.read_csv("PATH TO DATASET", parse_dates=['Date'])
df.set_index("Date", inplace=True)
df = df.asfreq("D")
df["Radiation"] = df["Radiation"].interpolate("time").bfill().ffill()


# STL Decomposition

stl = STL(df["Radiation"], seasonal=365)
res = stl.fit()
df["trend"] = res.trend
df["seasonal"] = res.seasonal
df["residual"] = res.resid

# STL Decomposition plot
plt.figure(figsize=(12, 8), dpi=300)
plt.subplot(4, 1, 1)
plt.plot(df["Radiation"], color='blue', linewidth=2, linestyle='--')
plt.title("Original", fontsize=16, fontweight='bold', fontname="Times New Roman")
plt.subplot(4, 1, 2)
plt.plot(df["trend"], color='red', linewidth=2, linestyle='--')
plt.title("Trend", fontsize=16, fontweight='bold', fontname="Times New Roman")
plt.subplot(4, 1, 3)
plt.plot(df["seasonal"], color='green', linewidth=2, linestyle='--')
plt.title("Seasonal", fontsize=16, fontweight='bold', fontname="Times New Roman")
plt.subplot(4, 1, 4)
plt.plot(df["residual"], color='orange', linewidth=2, linestyle='--')
plt.title("Residual", fontsize=16, fontweight='bold', fontname="Times New Roman")
plt.tight_layout()
plt.savefig("xgboost_stl.png", dpi=300, bbox_inches='tight')
plt.show()
plt.close()


# Feature Engineering

def create_features(data, target):
    df_feat = data.copy()
    df_feat["dayofyear"] = df_feat.index.dayofyear
    df_feat["month"] = df_feat.index.month
    df_feat["week_of_year"] = df_feat.index.isocalendar().week.astype(int)
    df_feat["lag1"] = df_feat[target].shift(1)
    df_feat["lag7"] = df_feat[target].shift(7)
    df_feat["rolling7"] = df_feat[target].rolling(7).mean()
    return df_feat.dropna()

df_feat = create_features(df, "Radiation")

# Train-test split
split_index = int(0.9 * len(df_feat))
train_full = df_feat.iloc[:split_index]
test = df_feat.iloc[split_index:]

features = ["dayofyear", "month", "week_of_year", "lag1", "lag7", "rolling7", "trend", "seasonal", "residual"]
target = "Radiation"


# Hyperparameter Tuning

print("Starting Randomized Search for XGBoost Hyperparameters...")
param_distributions = {
    'n_estimators': [500, 1000, 1500, 2000],
    'learning_rate': [0.001, 0.005, 0.01, 0.05],
    'max_depth': [5, 7, 10, 12, 15],
    'subsample': [0.6, 0.7, 0.8, 0.9, 1.0],
    'colsample_bytree': [0.6, 0.7, 0.8, 0.9, 1.0],
    'gamma': [0, 0.1, 0.2, 0.3],
    'min_child_weight': [1, 3, 5],
}

xgb_model = xgb.XGBRegressor(objective='reg:squarederror',
                             eval_metric='rmse',
                             random_state=42,
                             n_jobs=-1)

tscv = TimeSeriesSplit(n_splits=5)

random_search = RandomizedSearchCV(
    estimator=xgb_model,
    param_distributions=param_distributions,
    n_iter=50,
    scoring='neg_mean_squared_error',
    cv=tscv,
    verbose=2,
    random_state=42,
    n_jobs=-1
)

random_search.fit(train_full[features], train_full[target])

best_hyperparameters = random_search.best_params_
best_score = np.sqrt(-random_search.best_score_)

print("\nRandomized Search Complete.")
print(f"Best Hyperparameters: {best_hyperparameters}")
print(f"Best CV RMSE: {best_score:.6f}")


# Train Final Model

final_model = xgb.XGBRegressor(
    objective='reg:squarederror',
    eval_metric='rmse',
    random_state=42,
    n_jobs=-1,
    **best_hyperparameters
)
final_model.fit(train_full[features], train_full[target])

# Save model
final_model.save_model("xgboost_model_tuned.json")
print("\nModel saved as 'xgboost_model_tuned.json'.")


# Predictions

pred = final_model.predict(test[features])

rmse = np.sqrt(mean_squared_error(test[target], pred))
mae = mean_absolute_error(test[target], pred)
mape = mean_absolute_percentage_error(test[target], pred)

print(f"\n--- Final XGBoost Model Performance ---")
print(f"MAE  : {mae:.3f}")
print(f"MAPE : {mape:.2f}%")
print(f"RMSE : {rmse:.3f}")

# Overall Plot

styled_plot(test.index, test[target], pred,
            title="Overall Prediction (XGBoost)",
            save_path="xgboost_prediction_overall.png")


# December 2022 Plot

december_mask = (test.index >= "2022-12-01") & (test.index <= "2022-12-31")
true_dec = test[target][december_mask]
pred_dec = pd.Series(pred, index=test.index)[december_mask]

if not true_dec.empty:
    rmse_dec = np.sqrt(mean_squared_error(true_dec, pred_dec))
    mae_dec = mean_absolute_error(true_dec, pred_dec)
    mape_dec = mean_absolute_percentage_error(true_dec, pred_dec)

    print("\n December 2022 Evaluation:")
    print(f"MAE  : {mae_dec:.3f}")
    print(f"MAPE : {mape_dec:.2f}%")
    print(f"RMSE : {rmse_dec:.3f}")

    styled_plot(true_dec.index, true_dec, pred_dec,
                title="December 2022 Prediction (XGBoost)",
                save_path="xgboost_december_2022.png")
else:
    print("\n December 2022: No data in test set.")


# Seasonal Evaluation

season_masks = {
    "Winter": ((test.index.month == 12) | (test.index.month <= 2)),
    "Spring": ((test.index.month >= 3) & (test.index.month <= 5)),
    "Summer": ((test.index.month >= 6) & (test.index.month <= 8)),
    "Autumn": ((test.index.month >= 9) & (test.index.month <= 11)),
}

seasonal_results = []
for season, mask in season_masks.items():
    y_true_season = test[target][mask]
    y_pred_season = pd.Series(pred, index=test.index)[mask]

    if not y_true_season.empty:
        rmse_s = np.sqrt(mean_squared_error(y_true_season, y_pred_season))
        mae_s = mean_absolute_error(y_true_season, y_pred_season)
        mape_s = mean_absolute_percentage_error(y_true_season, y_pred_season)

        seasonal_results.append({
            "Season": season,
            "RMSE": rmse_s,
            "MAE": mae_s,
            "MAPE": mape_s
        })

        print(f"\n {season}")
        print(f"MAE  : {mae_s:.3f}")
        print(f"MAPE : {mape_s:.2f}%")
        print(f"RMSE : {rmse_s:.3f}")

        styled_plot(y_true_season.index, y_true_season, y_pred_season,
                    title=f"{season} Prediction (XGBoost)",
                    save_path=f"xgboost_season_{season.lower()}.png")
    else:
        print(f"\n {season}: No data in test set.")


# Save Metrics and Predictions

results_df = pd.DataFrame({
    "Date": test.index,
    "Actual": test[target],
    "Predicted": pred
})

seasonal_metrics_df = pd.DataFrame(seasonal_results)
overall_metrics = pd.DataFrame([{
    "Season": "Overall",
    "RMSE": rmse,
    "MAE": mae,
    "MAPE": mape
}])
seasonal_metrics_df = pd.concat([overall_metrics, seasonal_metrics_df], ignore_index=True)

if 'rmse_dec' in locals():
    dec_metrics = pd.DataFrame([{
        "Season": "December 2022",
        "RMSE": rmse_dec,
        "MAE": mae_dec,
        "MAPE": mape_dec
    }])
    seasonal_metrics_df = pd.concat([seasonal_metrics_df, dec_metrics], ignore_index=True)

with pd.ExcelWriter("xgboost_metrics_and_predictions_tuned.xlsx") as writer:
    results_df.to_excel(writer, sheet_name="All_Predictions", index=False)
    seasonal_metrics_df.to_excel(writer, sheet_name="Metrics_Summary", index=False)

print("\nMetrics and predictions saved to 'xgboost_metrics_and_predictions_tuned.xlsx'.")

